package org.uacalc.alg;

import java.util.*;
import org.uacalc.alg.sublat.*;
import org.uacalc.alg.conlat.*;
import org.uacalc.eq.*;
import org.uacalc.terms.*;
import org.uacalc.util.*;

/*
 * An algebra with an associated vector of elements that generates it. 
 * Repeats are allowed.
 * 
 */
public class AlgebraWithGeneratingVector implements Comparable<AlgebraWithGeneratingVector> {

  SmallAlgebra alg;
  int[] gensVector;
  
  public AlgebraWithGeneratingVector(SmallAlgebra alg, int[] vec) {
    this.alg = alg;
    this.gensVector = vec;
  }
  
  public SmallAlgebra getAlgebra() { return alg; }
  
  public int[] getVector() { return gensVector; }
  
  public boolean isImageOf(AlgebraWithGeneratingVector alg2) {
    if (alg2.getAlgebra().cardinality() < alg.cardinality()) return false;
    if (gensVector.length != alg2.getVector().length) return false;
    return SubalgebraLattice.extendToHomomorphism(alg2.getVector(), 
                                   gensVector, alg2.getAlgebra(), alg) != null;
    
  }

  public boolean equals(Object obj) {
    if (!(obj instanceof AlgebraWithGeneratingVector)) return false;
    AlgebraWithGeneratingVector alg2 = (AlgebraWithGeneratingVector)obj;
    return isImageOf(alg2) && alg2.isImageOf(this);
  }
  
  public int compareTo(AlgebraWithGeneratingVector alg2) {
    if (isImageOf(alg2)) {
      if (alg2.isImageOf(this)) return 0;
      return -1;
    }
    if (alg2.isImageOf(this)) return 1;
    return 0;
  }
  
  public static List<AlgebraWithGeneratingVector> siDecompose(
                              final SmallAlgebra alg, final int[] vec) {
    return siDecompose(alg, vec, null);
  }
  
  /**
   * Given an algebra and a vector of elements, this first forms the
   * subalgebra generated by the vector and then decomposes that into
   * subdirectly irreducible algebras.
   * 
   * @param alg
   * @param vec
   * @return
   */
  public static List<AlgebraWithGeneratingVector> siDecompose(
                                      final SmallAlgebra alg, final int[] vec, List<Equation> relations) {
    final Subalgebra B = alg.sub().Sg(vec);
    final int[] indexVec = new int[vec.length];
    for (int i = 0 ; i < vec.length; i++) {
      indexVec[i] = B.index(vec[i]);
    }
    if (relations != null && ! relations.isEmpty()) {
      List<Variable> vars = relations.get(0).getVariableList();
      Map<Variable,Integer> map = new HashMap<Variable,Integer>();
      int k = 0;
      for (Variable v : vars) {
        map.put(v, new Integer(indexVec[k++]));
      }
      Partition gamma = B.con().zero();
      for (Equation eq : relations) {
        int left = eq.leftSide().intEval(B, map);
        int rt = eq.rightSide().intEval(B, map);
        if (left != rt) gamma =  gamma.join(B.con().Cg(left, rt));
      }
      QuotientAlgebra C = new QuotientAlgebra(B, gamma);
      final int[] v = new int[indexVec.length];
      for (int i = 0; i < indexVec.length; i++) {
        v[i] = C.representativeIndex(gamma.representative(indexVec[i]));
      }
      return siDecompose(C, v, null);  // call siDecompose on this quotient.
    }
    //System.out.println("B (subalg) size = " + B.cardinality()
    //    + ", vec = " + ArrayString.toString(vec) 
    //    + ", indexVec = " + ArrayString.toString(indexVec));
    final List<Partition> decom = B.con().irredundantMeetDecomposition();
    final List<AlgebraWithGeneratingVector> ans = new ArrayList<AlgebraWithGeneratingVector>();
    for (Partition part : decom) {
      QuotientAlgebra C = new QuotientAlgebra(B, part);
      final int[] v = new int[indexVec.length];
      for (int i = 0; i < indexVec.length; i++) {
        v[i] = C.representativeIndex(part.representative(indexVec[i]));
      }
      //System.out.println("aprt = " + part + ", v = " + ArrayString.toString(v));
      ans.add(new AlgebraWithGeneratingVector(C, v));
    }
    return ans;
  }
  
  public String toString() {
    return "Alg with vector, alg size = " + getAlgebra().cardinality() + ", vec = " 
            + ArrayString.toString(getVector());
  }
  
}
